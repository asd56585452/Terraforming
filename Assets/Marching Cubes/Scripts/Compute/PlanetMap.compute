#pragma kernel CSMain
#include "/Includes/Noise.compute"

RWTexture3D<float> DensityTexture;
int3 textureSize;

float3 planetSize;
float noiseScale;
float noiseHeightMultiplier;
float3 seedOffset;
bool invertDensity;

float fbm(int numLayers, float lacunarity, float persistence, float scale, float3 pos) {
	float noise = 0;
	float frequency = scale / 100;
	float amplitude = 1;

	for (int i = 0; i < numLayers; i ++) {
		float n = 1-abs(snoise(pos * frequency)*2-1);
		//n*=n;
		noise += n * amplitude;

		amplitude *= persistence;
		frequency *= lacunarity;
	}

	return noise;
}

float calculateDensity(int3 cell) {
    float3 worldPos = ((float3) cell / ((float3) textureSize - 1.0) - 0.5f) * planetSize;

	float halfS = planetSize.y ;
	//float maxD = length(float3(halfS,halfS,halfS));

	//float fudge = 1;

	//float density = length(worldPos) / (maxD + fudge) - 0.5;
    float density = 0;

	// Noise
    float noise = fbm(6, 2, 0.5, noiseScale, worldPos + seedOffset) * noiseHeightMultiplier;

	density += noise;

	return density;
}

[numthreads(8,8,8)]
void CSMain (int3 id : SV_DispatchThreadID)
{
	if (id.x >= textureSize.x || id.y >= textureSize.y || id.z >= textureSize.z) {
		return;
	}

	float density = 0;

	const int b = 1;
	if (id.x >= textureSize.x-b || id.y >= textureSize.y-b || id.z >= textureSize.z-b) {
		density = 1;
	}
	else if (id.x <= b || id.y <= b || id.z <=b) {
		density = 1;
	}
	else {
		density = calculateDensity(id);
        if (invertDensity)
        {
            density *= -1;
        }
    }

	DensityTexture[id] = density;
}
